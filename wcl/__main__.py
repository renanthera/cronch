import json
from .request import Request
from .types import *

"""
1. each object uses the canonical GQL typename as its name
2. each object contains two sets of references: args and fields
2. each reference contains GQL typename, local aliased name and metadata
"""
"""
BASE KINDS:
SCALAR,
OBJECT,
ENUM

META KINDS:
NON_NULL,
LIST
"""

"""
TODO:
sort the objects
make sure i can use the type objects to make the thing :tm:
create a thing that finds the correct query objects
stringify
"""


class SchemaIntrospection:
  schema_location = 'wcl/introspection_query.json'
  tree = {
    'name': '__schema'
  }
  paginator = {}
  cacheable = True

  def __str__( self ):
    with open( self.schema_location, 'r' ) as handle:
      data = handle.read()
    return data

schema_query = SchemaIntrospection()
schema_request_data = Request( schema_query ).data

objects = {
  'ENUM': [
"""from ..query import GQL_ENUM

\"\"\"
ENUM TYPES
THIS FILE IS GENERATED BY `wcl/query.py`.
\"\"\""""
  ],
  'OBJECT': [
"""from ..query import *
from .enum import *
from .scalar import *

\"\"\"
OBJECT TYPES
THIS FILE IS GENERATED BY `wcl/query.py`.
\"\"\""""
  ]
}

tab = '  '
def handle_enum( entry ):
  assert entry[ 'kind' ] == 'ENUM'
  longest_str = max( [ len( enum_value[ 'name' ] ) for enum_value in entry[ 'enumValues' ] ] )
  lines = [
    f'class GQL_{entry["name"]}( GQL_ENUM ):',
    f'{tab}enum_values = [',
    *[
      f'{tab}{tab}\'{name}\',{" "*(longest_str-len(name))} # {desc}'
      for enum_value in entry['enumValues']
      if ( name := enum_value['name'] )
      if ( desc := enum_value['description'] )
    ],
    f'{tab}]'
  ] # yapf: disable
  return '\n'.join( lines )

def handle_object( entry ):
  def format_type( t ):
    type_arr = resolve_type( t )
    return '('.join( type_arr ) + ')' * ( len( type_arr ) - 1 ) + ","

  def resolve_type( t ):
    kind = t[ 'kind' ]
    if kind in [ 'OBJECT', 'SCALAR', 'ENUM' ]:
      name = t[ 'name' ]
      if kind != 'OBJECT':
        return [ f'GQL_{name}' ]
      else:
        return [ f'"GQL_{name}"' ]
    else:
      return [ f'GQL_{kind}' ] + resolve_type( t[ 'ofType' ] )

  def format_field( field ):
    def base_filter( field ):
      key_filter = [
        'name',
        'description'
      ]
      return [
        f'{tab}"{key}": "{value}",'
        for key, value in field.items()
        if key in key_filter
      ]

    def format_arg( arg ):
      return [
        '{',
        *[
          f'{line}'
          for line in base_filter( arg )
        ],
        f'{tab}"type": {format_type(arg["type"])}',
        '},'
      ]

    def format_args( args ):
      if args:
        return [
          '"args": [',
          *[
            f'{tab}{line}'
            for arg in args
            if ( arg_lines := format_arg( arg ) )
            for line in arg_lines
          ],
          ']'
        ]
      return []

    return [
      '{',
      *base_filter( field ),
      f'{tab}"type": {format_type(field["type"])}',
      *[
        f'{tab}{line}'
        for line in format_args( field[ 'args' ] )
      ],
      '},'
    ]

  assert entry[ 'kind' ] == 'OBJECT'
  lines = [
    f'class GQL_{entry["name"]}( GQL_OBJECT ):',
    f'{tab}fields = [',
    *[
      f'{tab}{tab}{line}'
      for field in entry[ 'fields' ]
      if ( formatted_field := format_field( field ) )
      for line in formatted_field
    ],
    f'{tab}]'
  ]
  print(json.dumps(entry, indent=2))
  print(json.dumps(lines, indent=2))
  return '\n'.join( lines )

for k in schema_request_data[ 'types' ]:
  kind = k[ 'kind' ]
  if kind in objects.keys():
    current = objects[ kind ]
    match kind:
      case 'ENUM':
        current.append( handle_enum( k ) )
      case 'OBJECT':
        current.append( handle_object( k ) )
      case _:
        pass

    objects.update( {
      kind: current
    } )
for kind, values in objects.items():
  with open( f'wcl/types/{kind.lower()}.py', 'w' ) as handle:
    handle.write( '\n\n'.join( values ) )

scalar.GQL_Boolean( True )
